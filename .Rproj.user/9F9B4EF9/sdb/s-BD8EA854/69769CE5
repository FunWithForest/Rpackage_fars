{
    "collab_server" : "",
    "contents" : "\n#Install and load the needed packages:\n# install.packages(\"devtools\")\n# install.packages(\"testthat\")\n# install.packages(\"roxygen2\")\n# install.packages(\"dplyr\")\n# install.packages(\"readr\")\n# install.packages(\"tidyr\")\n# install.packages(\"maps\")\n\n# library(roxygen2)\n# library(dplyr)\n# library(readr)\n# library(tidyr)\n# library(maps)\n# library(devtools)\n# library(testthat)\n\n#-------------------------------------------------------------------------------------------------\n\n#Declaring global variables:\nglobalVariables(names = c('STATE','MONTH','year'), package = 'fars', add = TRUE)\n\n#QPDF implementation:\nSys.setenv(R_QPDF= \"F:/Files/Programming/Coursera_Building R Packages/qpdf/bin/qpdf.exe\")\n\n\n#' Function \\code{fars_read}\n#'\n#' This is a function that tries to read in a specified csv file and outputs it as a table\n#' if the file has been found or exits with a warning message.\n#' Within the data object the content of the csv file is written if filename is found.\n#' The option progress = FALSE prevents from displaying a progress bar.\n#'\n#' @param filename It is a string that should contain the filename\n#'\n#' @return This function returns a data table created by the dplyr package.\n#' The package dplyr and readr are needed in order to make this package work.\n#'\n#' @examples\n#' fars_read(system.file(\"extdata\", \"accident_2015.csv.bz2\", package = \"fars\"))\n#'\n#' @importFrom readr read_csv\n#' @importFrom dplyr tbl_df\n#'\n#' @export\nfars_read <- function(filename) {\n        if(!file.exists(filename))\n                stop(\"file '\", filename, \"' does not existX\")\n                data <- suppressMessages({\n                readr::read_csv(filename, progress = FALSE)\n                })\n        dplyr::tbl_df(data)\n}\n\n\n#' Function \\code{make_filename}\n#'\n#' This function takes a year value as input and adds this value into a textstring for the zipped filename.\n#' As this is the last performed operation this is also the return value.\n#' sprintf is a generic C function that pastes a text string (coming from the base package).\n#' The output is created as accident_ followed by the value of the year.\n#' @param year Input of a numeric integer value for the year.\n#'\n#' @return A textstring is returned.\n#'\n#' @examples\n#' make_filename(2015)\n#'\n#' @export\nmake_filename <- function(year) {\n        year <- as.integer(year)\n        #changes due to package implementation of raw data:\n        #sprintf(\"accident_%d.csv.bz2\", year)\n        file <- sprintf(\"accident_%d.csv.bz2\", year)\n        system.file(\"extdata\", file, package = \"fars\")\n}\n\n\n#' Function \\code{fars_read_years}\n#'\n#' This function takes a vector of years as input and selects values for month and year row by row.\n#' @param years A vector of years.\n#' file takes the textstring from the \\code{make_filename} function.\n#' lapply loops over all years and with the tryCatch statement further changes are made (see below).\n#' dat takes the data of the files from the next filename.\n#' mutate is a function of the dplyr package and in this case it selects month and year.\n#' Importing this function from the dplyr package is needed.\n#'\n#' @return If an invalid year is taken from the selection an error will occur and nothing is returned.\n#' Else the values month and year are returned row by row.\n#'\n#' @examples\n#' fars_read_years(2013:2015)\n#' fars_read_years(2015)\n#'\n#' @importFrom dplyr mutate\n#' @importFrom dplyr select\n#'\n#' @export\nfars_read_years <- function(years) {\n        lapply(years, function(year) {\n                file <- make_filename(year)\n                tryCatch({\n                        dat <- fars_read(file)\n                        dplyr::mutate(dat, year = year) %>%\n                                dplyr::select(MONTH, year)\n                }, error = function(e) {\n                        warning(\"invalid year: \", year)\n                        return(NULL)\n                })\n        })\n}\n\n\n#' Function \\code{fars_summarize_years}\n#'\n#' This function takes the returned values of other functions and summarizes the values by year and month.\n#' @param years In the function call one ore more years are expected to be submitted.\n\n#' The dat_list object takes the input of the \\code{fars_read_years} function and delivers the years value\n#' to it with the call.\n#' bin_rows comes from the dplyr package and takes the dat_list object and groups it by year and month.\n#' spread comes from the tidyr package and reorganizes the data according to year and the summarized value of n.\n#'\n#' @return A table with the columns for the months and each year.\n#'\n#' @examples\n#' fars_summarize_years(2014:2015)\n#' fars_summarize_years(2015)\n#'\n#' @importFrom dplyr bind_rows\n#' @importFrom dplyr group_by\n#' @importFrom dplyr summarize\n#' @importFrom tidyr spread\n#'\n#' @export\nfars_summarize_years <- function(years) {\n        dat_list <- fars_read_years(years)\n        dplyr::bind_rows(dat_list) %>%\n                dplyr::group_by(year, MONTH) %>%\n                dplyr::summarize(n = n()) %>%\n                tidyr::spread(year, n)\n}\n\n#' Function \\code{fars_map_state}\n#'\n#' This function takes the state number and a specific year as arguments and prints out a map of accidents in the selected state.\n\n#' @param state.num This is a single integer value with the state number from the input.\n#' @param year This value is an input value that gives out either a single year or a range of several years.\n#'\n#' @return Either a message is given out when there are no accidents or a map of the state and its accidents is shown.\n#'\n#' @examples\n#' fars_map_state(1,2015)\n#'\n#' @importFrom dplyr filter\n#' @importFrom maps map\n#' @importFrom graphics points\n#'\n#' @export\nfars_map_state <- function(state.num, year) {\n        filename <- make_filename(year)\n        data <- fars_read(filename)\n        state.num <- as.integer(state.num)\n\n        if(!(state.num %in% unique(data$STATE)))\n                stop(\"invalid STATE number: \", state.num)\n        data.sub <- dplyr::filter(data, STATE == state.num)\n        if(nrow(data.sub) == 0L) {\n                message(\"no accidents to plot\")\n                return(invisible(NULL))\n        }\n        is.na(data.sub$LONGITUD) <- data.sub$LONGITUD > 900\n        is.na(data.sub$LATITUDE) <- data.sub$LATITUDE > 90\n        with(data.sub, {\n                maps::map(\"state\", ylim = range(LATITUDE, na.rm = TRUE),\n                          xlim = range(LONGITUD, na.rm = TRUE))\n                graphics::points(LONGITUD, LATITUDE, pch = 46)\n        })\n}\n\n#Coursera Week 4 PGA:\n#use_vignette(\"function_details\")\n\n#Add a test using the testthat package:\n#testthat::expect_that(fars_map_state(1,2019), throws_error(\"file 'accident_2019.csv.bz2' does not existX\"))\n\n#devtools::load_all()\n#devtools::check()\n\n\n",
    "created" : 1518769256705.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3236348298",
    "id" : "69769CE5",
    "lastKnownWriteTime" : 1519132947,
    "last_content_update" : 1519132947107,
    "path" : "F:/Files/Programming/Coursera_Building R Packages/fars/R/fars_functions.R",
    "project_path" : "R/fars_functions.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}